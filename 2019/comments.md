#### https://adventofcode.com/2019

Since I'll soon start a new job mainly using javascript, I thought I would do this year in js. Lezgooo.

After day 1 & 2 it's funny to see how I would have solved this in no time in python, and how I suffer with simple tasks in js!

Day 7 feels kind of shady, but I'm not sure this is because of the language. Maybe I wouldn't have found a cleaner solution in python. Nevertheless, it's quick (and not so dirty)!

I know I've said it already, but I really love puzzles which require to render some letters like the one on day 8 :)

It took me so much time to get a valid intcode computer for day 9 part 1 that I was surprised part 2 ran that easily. Mainly comprehension issue and stupid mistakes!

Day 10 part 2 took me longer than expected since I lost myself in sorting functions.

Day 12 part 2 is obviously suboptimal because it takes few minutes. Sure it's reasonable (~4min30), so it will stay that way, but still...

Day 13 part 2 took me sooooo much time. It was mainly comprehesion issues, implementation was easy (once you have a working Intcode, which I already had).

First time I implement a binary search (day 14 part 2) and I'm amazed how quickly it runs.

Once again, I had comprehension issues, this time for day 17 part 2. Well I also made a silly mistake and reverse printed the map, so my path was obviously wrong...

Oh my. More than 3min for day 18 part 1. It's ugly but that we'll do. First attempt on part 2 just ran for ever. Thanks to someone's hint on reddit, I used the fact that all quadrants could be handled independently. We do not need to keep track of the order of the robots. So if a robot is blocked at a door and the key is not in this quadrant, it's just like the door does not exist. Much easier and allows the code to run with minimal changes in about 100ms.

I had a nice solution for day 19 part 2, only with integer. But I guess at some point in the beam a slope varied a little, and I got some offset. I found the correct solution by visualising the beam in the predefined area, but wanted something more programatic. So I went for the full calculation of the slopes, but I'm not very happy with it. The '0.5' seems a little bit too arbitrary (even if it makes sense!)

I'm truly amazed byt the construction of day 21 puzzle, but I did not like it. I don't really know why but, still.

Oh my. Day 22 part 2 was just impossible. It has been so hard, I had to look for more than hints. It kind of felt like cheating, but afterall, this year was all about improving my JS skills and learning new stuff with this language. And I did, so I guess that still counts.

I don't know how I did to confuse myself that much for part 1. Then I was surprised how my first implementation for part 2 gave the correct answer XD

Day 24 part 2 is not recursive at all, but that works fine :)

Solved day 25 manually. I still don't know if I liked this one or not. It felt like too much work to do it programmatically, but just trying all possibilities manually (with method!) wasn't really fun. The discovery of the map and the various traps was funny though.
